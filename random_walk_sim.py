from pylab import *
import networkx as nx
import random as rd


# Initialize a random graph with N nodes and C edges and return
def initialize(N, C):
    # Used Copilot to figure out how to ensure generated graph is always connected
    while True:
        G = nx.gnm_random_graph(N, C)
        if nx.is_connected(G):
            break
    for i in G.nodes():
        G.nodes[i]['state'] = 0
    return G

# Simulate a random walk until all nodes are visited, return path 
def random_walk(G):
    start_node = rd.choice(list(G.nodes()))
    G.nodes[start_node]['state'] = 1
    current_node = start_node
    path = []

    while len(path) != len(G.nodes()): # while not all nodes visited
        path.append(current_node) # add current node to path
        G.nodes[current_node]['state'] = 1 # mark current node as visited

    ## This section generated by GitHub Copilot
       # Get unvisited neighbors
        unvisited_neighbors = [n for n in G.neighbors(current_node) if G.nodes[n]['state'] == 0]
        if unvisited_neighbors:
            next_node = rd.choice(unvisited_neighbors)
        else:
            # If all neighbors are visited, pick any neighbor (allows revisiting)
            next_node = rd.choice(list(G.neighbors(current_node)))

        
        current_node = next_node # set current node to the neighbor


   # while path !=
    
    return path     

def main():
    G = initialize(10,40)
    path  = random_walk(G)
    print(path)



main()